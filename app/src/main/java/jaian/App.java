/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package jaian;

import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

public class App {
    private static Token token, first;
    private static SymbolTable st = new SymbolTable();
    private static List<Function> code = new ArrayList<Function>();
    private static int seq = 0;  // ラベル用シーケンスナンバー
    private static final String[] argregs = { "rdi", "rsi", "rdx", "rcx", "r8", "r9" };  // 関数引数用レジスタ

    public static void main(String[] args) {
        if (args.length != 1) {
            System.err.println("Invalid arguments.");
            System.exit(1);
        }

        // トークナイズしてパースする
        // 結果はcodeに保存される
        String src = args[0];
        first = token = Token.tokenize(src);
        declaration();  // 変数宣言の処理
        program();

        // アセンブリの前半部分を出力
        System.out.println(".intel_syntax noprefix");

        // 各関数毎にコード生成
        for (int i = 0; i < code.size(); ++i) {
            gen_func(code.get(i));
        }
    }

    /** エラーを出力して終了 */
    // printfと同じ引数を取る
    public static void error(String fmt, Object... values) {
        System.err.printf(fmt, values);
        System.exit(1);
    }

    /** エラー位置を出力して終了 */
    public static void error_at(String fmt, Object... values) {
        Token current_line = token.current_line();
        System.err.printf(" \033[34m-->\033[0m %d:%d\n", token.line(), token.idx() - current_line.idx() + 1);
        System.err.println(current_line.str());
        if (0 < (token.idx() - current_line.idx())) {
            System.err.printf("%" + (token.idx() - current_line.idx()) + "s", "");
        }
        System.err.printf("%s ", String.join("", Collections.nCopies(token.len(), "^")));
        System.err.printf(fmt, values);
        System.exit(1);
    }

    /**
     * 次のトークンが期待している記号の時には、トークンを1つ読み進めてtrueを返す。
     * それ以外の場合はfalseを返す。
     */
    private static boolean consume(String op) {
        if (token.kind() != TokenKind.Punct || !token.str().equals(op)) {
            return false;
        }
        consume();
        return true;
    }

    /**
     * 次のトークンが期待しているTokenKindの時には、トークンを1つ読み進めてtrueを返す。
     * それ以外の場合はfalseを返す。
     */
    private static boolean consume(TokenKind kind) {
        if (token.kind() != kind) {
            return false;
        }
        consume();
        return true;
    }

    /** 無条件にトークンを1つ読み進める。 */
    private static void consume() {
        token = token.next();
    }

    /**
     * 次のトークンが識別子である場合、トークンを進めてそれを返す
     * それ以外の場合にはnullを返す。
     */
    private static Token consume_ident() {
        if (token.kind() != TokenKind.Ident) {
            return null;
        }
        Token tok = token;
        consume();
        return tok;
    }

    /**
     * 次のトークンがtypeである場合、トークンを進めてtypeを返す
     * それ以外の場合にはnullを返す。
     */
    private static Type consume_type() {
        switch (token.kind()) {
            case Int:     consume(); return Type.Int;
            case Boolean: consume(); return Type.Boolean;
            default:                 return null;
        }
    }

    /**
     * 次のトークンが識別子である場合、トークンを進めてそれを返す
     * それ以外の場合にはエラーを出力して終了する。
     */
    private static Token expect_ident() {
        if (token.kind() != TokenKind.Ident) {
            error_at("expected identifier");
        }
        Token tok = token;
        consume();
        return tok;
    }

    /**
     * 次のトークンが期待しているTokenKindのときには、トークンを1つ読み進める。
     * それ以外の場合にはエラーを報告して終了する。
     */
    private static void expect(TokenKind kind) {
        if (token.kind() != kind) {
            error_at("expected token \"%s\", but got \"%s\"", kind.toString().toLowerCase(), token.str());
        }
        consume();
    }

    /**
     * 次のトークンが期待している記号のときには、トークンを1つ読み進める。
     * それ以外の場合にはエラーを報告して終了する。
     */
    private static void expect(String op) {
        if (token.kind() != TokenKind.Punct || !token.str().equals(op)) {
            error_at("expected token \"%s\", but got \"%s\"", op, token.str());
        }
        consume();
    }

    /**
     * 次のトークンが数値の場合、トークンを1つ読み進めてその数値を返す。
     * それ以外の場合にはエラーを報告する。
     */
    private static int expect_number() {
        if (token.kind() != TokenKind.Num) {
            error_at("Not a number: \"%s\"", token.str());
        }
        int val = token.val();
        consume();
        return val;
    }

    /**
     * 次のトークンがType(型)の場合、トークンを1つ読み進めてそのTypeを返す。
     * それ以外の場合にはエラーを報告する。
     */
    private static Type expect_type() {
        switch (token.kind()) {
            case Int:     consume(); return Type.Int;
            case Boolean: consume(); return Type.Boolean;
            default: error_at("Not a type: \"%s\"", token.str());
        }
        return null;  // unreachable
    }

    /** 指定のノードがbooleanとして解釈されない場合、エラーを報告して終了。 */
    private static void expect_boolean(Node node) {
        switch (node.kind()) {
            case Eq:
            case Ne:
            case Lt:
            case Le:
            case True:
            case False: break;
            default: error_at("incompatible types: expected \"boolean\"");
        }
    }

    // program = function*
    private static void program() {
        int i = 0;
        token = first;
        while (!token.at_eof()) {
            code.add(function());
        }
    }

    // function = type ident "(" (param ("," param)*)? ")" "{" stmt* "}"
    // param = type ident
    // type = "int"
    private static Function function() {
        Function func = new Function();
        Type return_type = expect_type();
        Token ident = expect_ident();
        func.set_type(return_type);
        func.set_name(ident.str());

        // 仮引数
        expect("(");
        while (!consume(")")) {
            if (consume(TokenKind.Int)) {
                func.push_param(expect_ident());
            } else {
                expect(")");
                break;
            }
            if (!consume(",")) {
                expect(")");
                break;
            }
        }

        // 中身
        expect("{");
        while (!consume("}")) {
            func.push(stmt());
        }
        return func;
    }

    // declaration = "int" ident ("=" expr)? ("," ident ("=" expr)?)* ";"
    // int a;
    // int a, b;
    // int a = 1;
    // int a = 1, b;
    // int a, b = 2;
    // int a = 1, b = 2;
    // int a, int b (仮引数)
    private static void declaration() {
        while (!token.at_eof()) {
            // TokenKind.Typeまでスキップ
            while (true) {
                if (token.at_eof()) { return; }
                if (token.kind() == TokenKind.Int || token.kind() == TokenKind.Boolean) {
                    break;
                }
                consume();
            }
            Type type = expect_type();  // Typeトークンを消費
            do {
                Type new_type = consume_type();
                if (new_type != null) {
                    type = new_type;
                }
                Token tok = expect_ident();
                if (st.find_var(tok) != null) {
                    error_at("already defined");
                }
                if (consume("(")) {
                    // 関数は無視
                    break;
                }
                Obj new_obj = new Obj(tok.str(), type, st.offset() + 8);
                st.push(new_obj);
                if (!consume("=")) {
                    continue;
                }
                assign();
            } while (consume(","));
        }
    }

    // stmt = expr? ";"
    //      | declaration
    //      | "{" expr* "}"
    //      | "if" "(" expr ")" stmt ("else" stmt)?
    //      | "while" "(" expr ")" stmt
    //      | "for" "(" (declaration|expr)? ";" expr? ";" expr? ")" stmt
    //      | "return" expr ";"
    private static Node stmt() {
        // declaration
        if (consume(TokenKind.Int)) {
            Node node = assign_declaration();
            expect(";");
            return node;
        }

        // "{" expr* "}"
        if (consume("{")) {
            Node head = new Node();
            Node cur = head;
            while (!consume("}")) {
                cur.set_next(stmt());
                cur = cur.next();
            }
            Node node = Node.new_node(NodeKind.Block, null, null);
            node.set_body(head.next());
            return node;
        }

        // "if" "(" expr ")" stmt ("else" stmt)?
        if (consume(TokenKind.If)) {
            Node node = Node.new_node(NodeKind.If, null, null);
            expect("(");
            Node cond = expr();
            expect_boolean(cond);
            node.set_cond(cond);
            expect(")");
            node.set_then(stmt());
            if (consume(TokenKind.Else)) {
                node.set_els(stmt());
            }
            return node;
        }

        // "while" "(" expr ")" stmt
        if (consume(TokenKind.While)) {
            Node node = Node.new_node(NodeKind.While, null, null);
            expect("(");
            Node cond = expr();
            expect_boolean(cond);
            node.set_cond(cond);
            expect(")");
            node.set_then(stmt());
            return node;
        }

        // "for" "(" (declaration|expr)? ";" expr? ";" expr? ")" stmt
        if (consume(TokenKind.For)) {
            Node node = Node.new_node(NodeKind.For, null, null);
            expect("(");
            if (!consume(";")) {
                if (consume(TokenKind.Int)) {
                    node.set_init(assign_declaration());
                } else {
                    node.set_init(expr());
                }
                expect(";");
            }
            if (!consume(";")) {
                Node cond = expr();
                expect_boolean(cond);
                node.set_cond(cond);
                expect(";");
            }
            if (!consume(")")) {
                node.set_inc(expr());
                expect(")");
            }
            node.set_then(stmt());
            return node;
        }

        // "return" expr ";"
        if (consume(TokenKind.Return)) {
            Node node = Node.new_node(NodeKind.Return, expr(), null);
            expect(";");
            return node;
        }

        // ";"
        if (consume(";")) {
            return Node.new_node(NodeKind.Block, null, null);
        }

        // expr ";"
        Node node = expr();
        expect(";");
        return node;
    }

    // expr = assign
    private static Node expr() {
        return assign();
    }

    // assign = equality ("=" assign)?
    private static Node assign() {
        Node node = equality();
        if (consume("=")) {
            node = Node.new_node(NodeKind.Assign, node, assign());
        }
        return node;
    }

    // 宣言時専用の割り当て
    // 宣言のみで代入していない場合は無視
    // 関数宣言も無視
    // assign_declaration = "int" equality ("=" assign)? ("," equality ("=" assign)?)*
    private static Node assign_declaration() {
        Node head = new Node();
        Node cur = head;
        do {
            Node node = equality();
            if (!consume("=")) {
                continue;
            }
            cur.set_next(Node.new_node(NodeKind.Assign, node, assign()));
            cur = cur.next();
        } while (consume(","));
        Node node = Node.new_node(NodeKind.Block, null, null);
        node.set_body(head.next());
        return node;
    }

    // equality = relational ("==" relational | "!=" relational)*
    private static Node equality() {
        Node node = relational();

        while (true) {
            if (consume("==")) {
                node = Node.new_node(NodeKind.Eq, node, relational());
            } else if (consume("!=")) {
                node = Node.new_node(NodeKind.Ne, node, relational());
            } else {
                return node;
            }
        }
    }

    // relational = add ("<" add | "<=" add | ">" add | ">=" add)*
    private static Node relational() {
        Node node = add();

        while (true) {
            if (consume("<")) {
                node = Node.new_node(NodeKind.Lt, node, add());
            } else if (consume("<=")) {
                node = Node.new_node(NodeKind.Le, node, add());
            } else if (consume(">")) {
                node = Node.new_node(NodeKind.Lt, add(), node);
            } else if (consume(">=")) {
                node = Node.new_node(NodeKind.Le, add(), node);
            } else {
                return node;
            }
        }
    }

    // add = mul ("+" mul | "-" mul)*
    private static Node add() {
        Node node = mul();

        while (true) {
            if (consume("+")) {
                node = Node.new_node(NodeKind.Add, node, mul());
            } else if (consume("-")) {
                node = Node.new_node(NodeKind.Sub, node, mul());
            } else {
                return node;
            }
        }
    }

    // mul = unary ("*" unary | "/" unary)*
    private static Node mul() {
        Node node = unary();

        while (true) {
            if (consume("*")) {
                node = Node.new_node(NodeKind.Mul, node, unary());
            } else if (consume("/")) {
                node = Node.new_node(NodeKind.Div, node, unary());
            } else {
                return node;
            }
        }
    }

    // unary = ("+" | "-")? unary
    private static Node unary() {
        if (consume("+")) {
            return unary();
        }
        if (consume("-")) {
            return Node.new_node(NodeKind.Sub, Node.new_node_num(0), unary());
        }
        return primary();
    }

    // funccall = ident "(" (assign ("," assign)*)? ")"
    private static Node funccall(Token tok) {
        Node head = new Node();
        Node cur = head;
        while (!consume(")")) {
            if (cur != head) {
                consume(",");
            }
            cur.set_next(assign());
            cur = cur.next();
        }
        Node node = Node.new_node(NodeKind.FuncCall, null, null);
        node.set_funcname(tok.str());
        node.set_args(head.next());
        return node;
    }

    // primary = "(" expr ")" | ident | ident func-args? | num | boolean
    private static Node primary() {
        // 次のトークンが "(" なら、 "(" expr ")" のはず
        if (consume("(")) {
            Node node = expr();
            expect(")");
            return node;
        }

        Token tok = consume_ident();
        if (tok != null) {
            // 識別子の次が括弧の場合、関数である。
            if (consume("(")) {
                return funccall(tok);
            }
            // そうでなければ変数
            Node node = Node.new_node(NodeKind.Var, null, null);
            Obj obj = st.find_var(tok);
            if (obj == null) {
                token = tok;  // 1つ前のトークンへ戻る
                error_at("cannot find symbol");
            }
            node.set_offset(obj.offset());
            return node;
        }

        // boolean型
        if (token.kind() == TokenKind.True) {
            consume();
            return Node.new_node(NodeKind.True, null, null);
        } else if (token.kind() == TokenKind.False) {
            consume();
            return Node.new_node(NodeKind.False, null, null);
        }

        // そうでなければ数値のはず
        return Node.new_node_num(expect_number());
    }

    /** 連番をインクリメントして返す */
    private static int sequence() {
        return seq++;
    }

    /** 関数単位のコード生成 */
    private static void gen_func(Function func) {
        // 関数のラベル
        System.out.printf(".globl %s\n", func.name());
        System.out.printf("%s:\n", func.name());

        // プロローグ
        // 変数の領域を確保する
        System.out.println("    push rbp");
        System.out.println("    mov rbp, rsp");
        System.out.printf("    sub rsp, %d\n", st.offset());

        // レジスタから仮引数へ保存する
        int i = 0;
        for (Token param: func.params()) {
            System.out.printf("    mov [rbp-%d], %s\n", st.find_var(param).offset(), argregs[i++]);
        }

        // 先頭の式から順にコード生成
        for (i = 0; i < func.size(); ++i) {
            gen(func.get(i));
        }

        // 式の評価結果としてスタックに一つの値が残っている
        // はずなので、スタックが溢れないようにポップしておく
        System.out.println("    pop rax");

        // エピローグ
        // 最後の式の結果がRAXに残っているのでそれが返り値になる
        System.out.println("    mov rsp, rbp");
        System.out.println("    pop rbp");
        System.out.println("    ret");
    }

    /** 式を左辺値として評価 */
    private static void gen_val(Node node) {
        if (node.kind() != NodeKind.Var) {
            error("not a variable");
        }
        System.out.printf("    mov rax, rbp\n");
        System.out.printf("    sub rax, %d\n", node.offset());
        System.out.printf("    push rax\n");
    }

    /** コード生成 */
    private static void gen(Node node) {
        switch (node.kind()) {
            case Num:
                System.out.printf("    push %d\n", node.val());
                return;
            case True:
                System.out.println("    push 1");
                return;
            case False:
                System.out.println("    push 0");
                return;
            case Var:
                gen_val(node);
                System.out.println("    pop rax");
                System.out.println("    mov rax, [rax]");
                System.out.println("    push rax");
                return;
            case Assign:
                gen_val(node.lhs());
                gen(node.rhs());
                System.out.println("    pop rdi");
                System.out.println("    pop rax");
                System.out.println("    mov [rax], rdi");
                System.out.println("    push rdi");
                return;
            case Block:
                for (Node stmt = node.body(); stmt != null; stmt = stmt.next()) {
                    gen(stmt);
                }
                return;
            case Return:
                gen(node.lhs());
                System.out.println("    pop rax");
                System.out.println("    mov rsp, rbp");
                System.out.println("    pop rbp");
                System.out.println("    ret");
                return;
            case FuncCall:
                int nargs = 0;
                for (Node arg = node.args(); arg != null; arg = arg.next()) {
                    // 実引数の計算結果(rax)をスタックにpushしている
                    gen(arg);
                    ++nargs;
                }
                // 6つより多い引数はとりあえず実装しない
                if (6 < nargs) {
                    error("Not supported arguments greater than 6: '%s'", node.funcname());
                }
                // 引数6以下は専用のレジスタに格納
                for (int i = nargs - 1; 0 <= i; --i) {
                    // スタックから引数をレジスタにpop
                    System.out.printf("    pop %s\n", argregs[i]);
                }
                System.out.printf("    call %s\n", node.funcname());
                System.out.printf("    push rax\n");
                return;
            case If: {
                int count = sequence();
                gen(node.cond());
                System.out.println("    pop rax");
                System.out.println("    cmp rax, 0");
                if (node.els() != null) {
                    System.out.printf("    je .L.else.%d\n", count);
                    gen(node.then());
                    System.out.printf("    jmp .L.end.%d\n", count);
                    System.out.printf(".L.else.%d:\n", count);
                    gen(node.els());
                    System.out.printf(".L.end.%d:\n", count);
                } else {
                    System.out.printf("    je .L.end.%d\n", count);
                    gen(node.then());
                    System.out.printf(".L.end.%d:\n", count);
                }
                return;
            }
            case While: {
                int count = sequence();
                System.out.printf(".L.begin.%d:\n", count);
                gen(node.cond());
                System.out.println("    pop rax");
                System.out.println("    cmp rax, 0");
                System.out.printf("    je .L.end.%d\n", count);
                gen(node.then());
                System.out.printf("    jmp .L.begin.%d\n", count);
                System.out.printf(".L.end.%d:\n", count);
                return;
            }
            case For: {
                int count = sequence();
                if (node.init() != null) {
                    gen(node.init());
                }
                System.out.printf(".L.begin.%d:\n", count);
                if (node.cond() != null) {
                    gen(node.cond());
                    System.out.println("    pop rax");
                    System.out.println("    cmp rax, 0");
                    System.out.printf("    je .L.end.%d\n", count);
                }
                gen(node.then());
                if (node.inc() != null) {
                    gen(node.inc());
                }
                System.out.printf("    jmp .L.begin.%d\n", count);
                System.out.printf(".L.end.%d:\n", count);
                return;
            }
        }

        gen(node.lhs());
        gen(node.rhs());

        System.out.println("    pop rdi");
        System.out.println("    pop rax");

        switch (node.kind()) {
            case Add:
                System.out.println("    add rax, rdi");
                break;
            case Sub:
                System.out.println("    sub rax, rdi");
                break;
            case Mul:
                System.out.println("    imul rax, rdi");
                break;
            case Div:
                System.out.println("    cqo");
                System.out.println("    idiv rdi");
                break;
            case Eq:
                System.out.println("    cmp rax, rdi");
                System.out.println("    sete al");
                System.out.println("    movzb rax, al");
                break;
            case Ne:
                System.out.println("    cmp rax, rdi");
                System.out.println("    setne al");
                System.out.println("    movzb rax, al");
                break;
            case Lt:
                System.out.println("    cmp rax, rdi");
                System.out.println("    setl al");
                System.out.println("    movzb rax, al");
                break;
            case Le:
                System.out.println("    cmp rax, rdi");
                System.out.println("    setle al");
                System.out.println("    movzb rax, al");
                break;
        }

        System.out.println("    push rax");
    }
}

