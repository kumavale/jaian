/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package jaian;

import java.util.List;
import java.util.ArrayList;
import java.util.Collections;

public class App {
    private static Token token, first;
    private static SymbolTable st = new SymbolTable();
    private static List<Function> code = new ArrayList<Function>();
    private static Function current_func;
    private static int seq = 0;  // ラベル用シーケンスナンバー
    private static final String[] argregs8  = { "dil", "sil",  "dl",  "cl", "r8b", "r9b" };  // 引数用レジスタ( 8bit)
    private static final String[] argregs64 = { "rdi", "rsi", "rdx", "rcx",  "r8",  "r9" };  // 引数用レジスタ(64bit)

    public static void main(String[] args) {
        if (args.length != 1) {
            System.err.println("Invalid arguments.");
            System.exit(1);
        }

        // トークナイズしてパースする
        // 結果はcodeに保存される
        String src = args[0];
        first = token = Token.tokenize(src);
        declaration();  // 変数宣言の処理
        program();

        // アセンブリの前半部分を出力
        System.out.println(".intel_syntax noprefix");

        // 各関数毎にコード生成
        for (int i = 0; i < code.size(); ++i) {
            gen_func(code.get(i));
        }
    }

    /** エラーを出力して終了 */
    // printfと同じ引数を取る
    public static void error(String fmt, Object... values) {
        System.err.printf(fmt, values);
        System.exit(1);
    }

    /** エラー位置を出力して終了 */
    public static void error_at(String fmt, Object... values) {
        Token current_line = token.current_line();
        System.err.printf(" \033[34m-->\033[0m %d:%d\n", token.line(), token.idx() - current_line.idx() + 1);
        System.err.println(current_line.str());
        if (0 < (token.idx() - current_line.idx())) {
            System.err.printf("%" + (token.idx() - current_line.idx()) + "s", "");
        }
        System.err.printf("\033[31m%s\033[0m ", String.join("", Collections.nCopies(token.len(), "^")));
        System.err.printf(fmt, values);
        System.exit(1);
    }

    /**
     * 次のトークンが期待している記号の時には、トークンを1つ読み進めてtrueを返す。
     * それ以外の場合はfalseを返す。
     */
    private static boolean consume(String op) {
        if (token.kind() != TokenKind.Punct || !token.str().equals(op)) {
            return false;
        }
        consume();
        return true;
    }

    /**
     * 次のトークンが期待しているTokenKindの時には、トークンを1つ読み進めてtrueを返す。
     * それ以外の場合はfalseを返す。
     */
    private static boolean consume(TokenKind kind) {
        if (token.kind() != kind) {
            return false;
        }
        consume();
        return true;
    }

    /** 無条件にトークンを1つ読み進める。 */
    private static void consume() {
        if (token.next() != null) {
            token = token.next();
        }
    }

    /** 無条件にトークンを1つ戻る。 */
    private static void back() {
        if (token.prev() != null) {
            token = token.prev();
        }
    }

    /**
     * 次のトークンが識別子である場合、トークンを進めてそれを返す
     * それ以外の場合にはnullを返す。
     */
    private static Token consume_ident() {
        if (token.kind() != TokenKind.Ident) {
            return null;
        }
        Token tok = token;
        consume();
        return tok;
    }

    /**
     * 次のトークンがtypeである場合、トークンを進めてtypeを返す
     * それ以外の場合にはnullを返す。
     */
    private static Type consume_type() {
        switch (token.kind()) {
            case Int:     consume(); return Type.Int;
            case Char:    consume(); return Type.Char;
            case Boolean: consume(); return Type.Boolean;
            default:                 return null;
        }
    }

    /**
     * 次のトークンが識別子である場合、トークンを進めてそれを返す
     * それ以外の場合にはエラーを出力して終了する。
     */
    private static Token expect_ident() {
        if (token.kind() != TokenKind.Ident) {
            error_at("expected identifier");
        }
        Token tok = token;
        consume();
        return tok;
    }

    /**
     * 次のトークンが期待しているTokenKindのときには、トークンを1つ読み進める。
     * それ以外の場合にはエラーを報告して終了する。
     */
    private static void expect(TokenKind kind) {
        if (token.kind() != kind) {
            error_at("expected token \"%s\", but got \"%s\"", kind.toString().toLowerCase(), token.str());
        }
        consume();
    }

    /**
     * 次のトークンが期待している記号のときには、トークンを1つ読み進める。
     * それ以外の場合にはエラーを報告して終了する。
     */
    private static void expect(String op) {
        if (token.kind() != TokenKind.Punct || !token.str().equals(op)) {
            error_at("expected token \"%s\", but got \"%s\"", op, token.str());
        }
        consume();
    }

    /**
     * 次のトークンが数値の場合、トークンを1つ読み進めてその数値を返す。
     * それ以外の場合にはエラーを報告する。
     */
    private static int expect_number() {
        if (token.kind() != TokenKind.Num) {
            error_at("Not a number: \"%s\"", token.str());
        }
        int val = token.val();
        consume();
        return val;
    }

    /**
     * 次のトークンがType(型)の場合、トークンを1つ読み進めてそのTypeを返す。
     * それ以外の場合にはエラーを報告する。
     */
    private static Type expect_type() {
        switch (token.kind()) {
            case Int:     consume(); return Type.Int;
            case Char:    consume(); return Type.Char;
            case Boolean: consume(); return Type.Boolean;
            default: error_at("Not a type: \"%s\"", token.str());
        }
        return null;  // unreachable
    }

    /** 指定のノードがbooleanとして解釈されない場合、エラーを報告して終了。 */
    private static void expect_boolean(Node node) {
        switch (node.kind()) {
            case Eq:
            case Ne:
            case Lt:
            case Le:
            case True:
            case False: break;
            default: error_at("incompatible types: expected \"boolean\"");
        }
    }

    // program = function*
    private static void program() {
        int i = 0;
        token = first;
        while (!token.at_eof()) {
            code.add(function());
        }
    }

    // function = type ident "(" (param ("," param)*)? ")" "{" stmt* "}"
    // param = type ident
    // type = "int" | "char" | "boolean"
    private static Function function() {
        Function func = new Function();
        current_func = func;
        Type return_type = expect_type();
        Token ident = expect_ident();
        func.set_type(return_type);
        func.set_name(ident.str());

        // 仮引数
        expect("(");
        while (!consume(")")) {
            if (consume_type() != null) {
                func.push_param(expect_ident());
            } else {
                expect(")");
                break;
            }
            if (!consume(",")) {
                expect(")");
                break;
            }
        }

        // 中身
        expect("{");
        while (!consume("}")) {
            func.push(stmt());
        }
        return func;
    }

    // declaration = "int" ident ("=" expr)? ("," ident ("=" expr)?)* ";"
    //             | "int" ident "[" num "]" ";"  // TODO 配列の初期化
    // int a;
    // int a, b;
    // int a = 1;
    // int a = 1, b;
    // int a, b = 2;
    // int a = 1, b = 2;
    // int a, int b (仮引数)
    // int a[10]; // 数値リテラルのみ
    private static void declaration() {
        while (!token.at_eof()) {
            // TokenKind.Typeまでスキップ
            while (true) {
                if (token.at_eof()) { return; }
                if (token.is_type()) { break; }
                consume();
            }
            Type type = expect_type();  // Typeトークンを消費
            do {
                if (token.is_type()) {
                    type = consume_type();
                }
                Token tok = expect_ident();
                if (st.find_var(tok) != null) {
                    back();
                    error_at("already defined");
                }
                if (consume("(")) {
                    // 関数は無視
                    break;
                }
                // 配列
                if (consume("[")) {
                    int element = expect_number();
                    expect("]");
                    Obj new_obj = new Obj(tok.str(), type, st.offset() + type.size(), element);
                    st.push(new_obj, element);
                } else {
                    Obj new_obj = new Obj(tok.str(), type, st.offset() + type.size(), 0);
                    st.push(new_obj, 1);
                }
                if (!consume("=")) {
                    continue;
                }
                assign();
            } while (consume(","));
        }
    }

    // stmt = expr? ";"
    //      | declaration
    //      | "{" expr* "}"
    //      | "if" "(" expr ")" stmt ("else" stmt)?
    //      | "while" "(" expr ")" stmt
    //      | "for" "(" (declaration|expr)? ";" expr? ";" expr? ")" stmt
    //      | "return" expr ";"
    private static Node stmt() {
        // declaration
        if (token.is_type()) {
            Type type = consume_type();
            Node node = assign_declaration(type);
            expect(";");
            return node;
        }

        // "{" expr* "}"
        if (consume("{")) {
            Node head = new Node();
            Node cur = head;
            while (!consume("}")) {
                cur.set_next(stmt());
                cur = cur.next();
            }
            Node node = Node.new_node(NodeKind.Block, null, null);
            node.set_body(head.next());
            return node;
        }

        // "if" "(" expr ")" stmt ("else" stmt)?
        if (consume(TokenKind.If)) {
            Node node = Node.new_node(NodeKind.If, null, null);
            expect("(");
            Node cond = expr();
            expect_boolean(cond);
            node.set_cond(cond);
            expect(")");
            node.set_then(stmt());
            if (consume(TokenKind.Else)) {
                node.set_els(stmt());
            }
            return node;
        }

        // "while" "(" expr ")" stmt
        if (consume(TokenKind.While)) {
            Node node = Node.new_node(NodeKind.While, null, null);
            expect("(");
            Node cond = expr();
            expect_boolean(cond);
            node.set_cond(cond);
            expect(")");
            node.set_then(stmt());
            return node;
        }

        // "for" "(" (declaration|expr)? ";" expr? ";" expr? ")" stmt
        if (consume(TokenKind.For)) {
            Node node = Node.new_node(NodeKind.For, null, null);
            expect("(");
            if (!consume(";")) {
                if (token.is_type()) {
                    Type type = consume_type();
                    node.set_init(assign_declaration(type));
                } else {
                    node.set_init(expr());
                }
                expect(";");
            }
            if (!consume(";")) {
                Node cond = expr();
                expect_boolean(cond);
                node.set_cond(cond);
                expect(";");
            }
            if (!consume(")")) {
                node.set_inc(expr());
                expect(")");
            }
            node.set_then(stmt());
            return node;
        }

        // "return" expr ";"
        if (consume(TokenKind.Return)) {
            Node return_value = expr();
            if (return_value.type() != current_func.type() && return_value.type() != null) {
                if (return_value.type() == Type.Literal) {
                    return_value.set_type(current_func.type());
                // TODO: キャスト
                //} else {
                //    back();
                //    error_at("mismatched return type");
                }
            }
            Node node = Node.new_node(NodeKind.Return, return_value, null);
            expect(";");
            return node;
        }

        // ";"
        if (consume(";")) {
            return Node.new_node(NodeKind.Block, null, null);
        }

        // expr ";"
        Node node = expr();
        expect(";");
        return node;
    }

    // expr = assign
    private static Node expr() {
        return assign();
    }

    // assign = equality ("=" assign)?
    private static Node assign() {
        Node lhs = equality();
        if (consume("=")) {
            switch (lhs.kind()) {
                case Var:
                case Array: break;
                default: back(); back(); error_at("invalid assign");
            }
            Node rhs = assign();
            if (lhs.type() != rhs.type()) {
                if (rhs.type() == Type.Literal) {
                    rhs.set_type(lhs.type());
                } else {
                    back();
                    error_at("mismatched types");
                }
            }
            lhs = Node.new_node(NodeKind.Assign, lhs, rhs);
            lhs.set_type(rhs.type());
        }
        return lhs;
    }

    // 宣言時専用の割り当て
    // 宣言のみで代入していない場合は無視
    // 関数宣言も無視
    // assign_declaration = type equality ("=" assign)? ("," equality ("=" assign)?)*
    private static Node assign_declaration(Type type) {
        Node head = new Node();
        Node cur = head;
        do {
            Node lhs = equality();
            lhs.set_type(type);
            if (!consume("=")) {
                continue;
            }
            Node rhs = assign();
            if (lhs.type() != rhs.type()) {
                if (rhs.type() == Type.Literal) {
                    rhs.set_type(lhs.type());
                } else {
                    back();
                    error_at("mismatched types");
                }
            }
            cur.set_next(Node.new_node(NodeKind.Assign, lhs, rhs));
            cur = cur.next();
        } while (consume(","));
        Node node = Node.new_node(NodeKind.Block, null, null);
        node.set_body(head.next());
        return node;
    }

    // equality = relational ("==" relational | "!=" relational)*
    private static Node equality() {
        Node node = relational();

        while (true) {
            if (consume("==")) {
                node = Node.new_node(NodeKind.Eq, node, relational());
            } else if (consume("!=")) {
                node = Node.new_node(NodeKind.Ne, node, relational());
            } else {
                return node;
            }
            node.set_type(Type.Boolean);
        }
    }

    // relational = add ("<" add | "<=" add | ">" add | ">=" add)*
    private static Node relational() {
        Node node = add();

        while (true) {
            if (consume("<")) {
                node = Node.new_node(NodeKind.Lt, node, add());
            } else if (consume("<=")) {
                node = Node.new_node(NodeKind.Le, node, add());
            } else if (consume(">")) {
                node = Node.new_node(NodeKind.Lt, add(), node);
            } else if (consume(">=")) {
                node = Node.new_node(NodeKind.Le, add(), node);
            } else {
                return node;
            }
            node.set_type(Type.Boolean);
        }
    }

    // add = mul ("+" mul | "-" mul)*
    private static Node add() {
        Node node = mul();

        while (true) {
            if (consume("+")) {
                Type type = node.type();
                node = Node.new_node(NodeKind.Add, node, mul());
                node.set_type(type);
            } else if (consume("-")) {
                Type type = node.type();
                node = Node.new_node(NodeKind.Sub, node, mul());
                node.set_type(type);
            } else {
                return node;
            }
        }
    }

    // mul = unary ("*" unary | "/" unary)*
    private static Node mul() {
        Node node = unary();

        while (true) {
            if (consume("*")) {
                Type type = node.type();
                node = Node.new_node(NodeKind.Mul, node, unary());
                node.set_type(type);
            } else if (consume("/")) {
                Type type = node.type();
                node = Node.new_node(NodeKind.Div, node, unary());
                node.set_type(type);
            } else {
                return node;
            }
        }
    }

    // unary = ("+" | "-")? unary
    private static Node unary() {
        if (consume("+")) {
            return unary();
        }
        if (consume("-")) {
            Node unary = unary();
            Node node = Node.new_node(NodeKind.Sub, Node.new_node_num(0), unary);
            node.set_type(unary.type());
            return node;
        }
        return primary();
    }

    // funccall = ident "(" (assign ("," assign)*)? ")"
    private static Node funccall(Token tok) {
        Node head = new Node();
        Node cur = head;
        while (!consume(")")) {
            if (cur != head) {
                consume(",");
            }
            cur.set_next(assign());
            cur = cur.next();
        }
        Node node = Node.new_node(NodeKind.FuncCall, null, null);
        node.set_funcname(tok.str());
        node.set_args(head.next());
        return node;
    }

    // primary = "(" expr ")" | ident ("[" expr "]")? | ident func-args? | num | boolean
    private static Node primary() {
        // 次のトークンが "(" なら、 "(" expr ")" のはず
        if (consume("(")) {
            Node node = expr();
            expect(")");
            return node;
        }

        Token ident = consume_ident();
        if (ident != null) {
            // 識別子の次が括弧の場合、関数である。
            if (consume("(")) {
                return funccall(ident);
            }
            // そうでなければ変数
            Obj val = st.find_var(ident);
            if (val == null) {
                back();
                error_at("cannot find symbol");
            }
            // 配列
            // TODO postfix = primary ("[" expr "]")*
            if (consume("[")) {
                if (!val.is_array()) {
                    token = ident;
                    error_at("not a array");
                }
                Node node = Node.new_node(NodeKind.Array, null, null);
                node.set_element(expr());
                node.set_offset(val.offset());
                node.set_type(val.type());
                expect("]");
                return node;
            } else {
                Node node = Node.new_node(NodeKind.Var, null, null);
                node.set_offset(val.offset());
                node.set_type(val.type());
                return node;
            }
        }

        // boolean型
        if (token.kind() == TokenKind.True) {
            consume();
            Node node = Node.new_node(NodeKind.True, null, null);
            node.set_type(Type.Boolean);
            return node;
        } else if (token.kind() == TokenKind.False) {
            consume();
            Node node = Node.new_node(NodeKind.False, null, null);
            node.set_type(Type.Boolean);
            return node;
        }

        // そうでなければ数値のはず
        Node node = Node.new_node_num(expect_number());
        node.set_type(Type.Literal);
        return node;
    }

    /** 連番をインクリメントして返す */
    private static int sequence() {
        return seq++;
    }

    /** 関数単位のコード生成 */
    private static void gen_func(Function func) {
        current_func = func;

        // 関数のラベル
        System.out.printf(".globl %s\n", func.name());
        System.out.printf("%s:\n", func.name());

        // プロローグ
        // 変数の領域を確保する
        System.out.println("    push rbp");
        System.out.println("    mov rbp, rsp");
        System.out.printf("    sub rsp, %d\n", st.offset());

        // レジスタから仮引数へ保存する
        int i = 0;
        for (Token param: func.params()) {
            Obj val = st.find_var(param);
            if (val.type().size() == 1) {
                System.out.printf("    mov [rbp-%d], %s\n", val.offset(), argregs8[i++]);
            } else {
                System.out.printf("    mov [rbp-%d], %s\n", val.offset(), argregs64[i++]);
            }
        }

        // 先頭の式から順にコード生成
        for (i = 0; i < func.size(); ++i) {
            gen(func.get(i));
        }

        // 式の評価結果としてスタックに一つの値が残っている
        // はずなので、スタックが溢れないようにポップしておく
        System.out.println("    pop rax");

        // エピローグ
        // 最後の式の結果がRAXに残っているのでそれが返り値になる
        System.out.println("    mov rsp, rbp");
        System.out.println("    pop rbp");
        System.out.println("    ret");
    }

    /** 式を左辺値として評価 */
    private static void gen_val(Node node) {
        if (node.kind() != NodeKind.Var) {
            error("not a variable");
        }
        System.out.printf("    mov rax, rbp\n");
        System.out.printf("    sub rax, %d\n", node.offset());
        System.out.printf("    push rax\n");
    }

    /** 式を左辺値として評価(配列) */
    private static void gen_array(Node node) {
        if (node.kind() != NodeKind.Array) {
            error("not a array");
        }
        gen(node.element());
        System.out.printf("    pop rdi\n");
        System.out.printf("    mov rax, rbp\n");
        System.out.printf("    sub rax, %d\n", node.offset());
        System.out.printf("    imul rdi, %d\n", node.type().size());
        System.out.printf("    sub rax, rdi\n");
        System.out.printf("    push rax\n");
    }

    /** コード生成 */
    private static void gen(Node node) {
        switch (node.kind()) {
            case Num:
                System.out.printf("    push %d\n", node.val());
                return;
            case True:
                System.out.println("    push 1");
                return;
            case False:
                System.out.println("    push 0");
                return;
            case Var:
                gen_val(node);
                System.out.println("    pop rax");
                if (node.type().size() == 1) {
                    System.out.println("    movsx rax, BYTE PTR [rax]");
                } else {
                    System.out.println("    mov rax, [rax]");
                }
                System.out.println("    push rax");
                return;
            case Array:
                gen_array(node);
                System.out.println("    pop rax");
                if (node.type().size() == 1) {
                    System.out.println("    movsx rax, BYTE PTR [rax]");
                } else {
                    System.out.println("    mov rax, [rax]");
                }
                System.out.println("    push rax");
                return;
            case Assign:
                // 左辺は変数か配列でなければならない
                switch (node.lhs().kind()) {
                    case Var:   gen_val  (node.lhs()); break;
                    case Array: gen_array(node.lhs()); break;
                    default: error("invalid assign");
                }
                gen(node.rhs());
                System.out.println("    pop rdi");  // rhsの結果
                System.out.println("    pop rax");  // lhsのアドレス
                if (node.lhs().type().size() == 1) {
                    System.out.println("    mov [rax], dil");
                } else {
                    System.out.println("    mov [rax], rdi");
                }
                System.out.println("    push rdi");
                return;
            case Block:
                for (Node stmt = node.body(); stmt != null; stmt = stmt.next()) {
                    gen(stmt);
                }
                return;
            case Return:
                gen(node.lhs());
                System.out.println("    pop rax");
                System.out.println("    mov rsp, rbp");
                System.out.println("    pop rbp");
                System.out.println("    ret");
                return;
            case FuncCall:
                int nargs = 0;
                for (Node arg = node.args(); arg != null; arg = arg.next()) {
                    // 実引数の計算結果(rax)をスタックにpushしている
                    gen(arg);
                    ++nargs;
                }
                // 6つより多い引数はとりあえず実装しない
                if (6 < nargs) {
                    error("Not supported arguments greater than 6: '%s'", node.funcname());
                }
                // 引数6以下は専用のレジスタに格納
                for (int i = nargs - 1; 0 <= i; --i) {
                    // スタックから引数をレジスタにpop
                    System.out.printf("    pop %s\n", argregs64[i]);
                }
                System.out.printf("    call %s\n", node.funcname());
                System.out.printf("    push rax\n");
                return;
            case If: {
                int count = sequence();
                gen(node.cond());
                System.out.println("    pop rax");
                System.out.println("    cmp rax, 0");
                if (node.els() != null) {
                    System.out.printf("    je .L.else.%d\n", count);
                    gen(node.then());
                    System.out.printf("    jmp .L.end.%d\n", count);
                    System.out.printf(".L.else.%d:\n", count);
                    gen(node.els());
                    System.out.printf(".L.end.%d:\n", count);
                } else {
                    System.out.printf("    je .L.end.%d\n", count);
                    gen(node.then());
                    System.out.printf(".L.end.%d:\n", count);
                }
                return;
            }
            case While: {
                int count = sequence();
                System.out.printf(".L.begin.%d:\n", count);
                gen(node.cond());
                System.out.println("    pop rax");
                System.out.println("    cmp rax, 0");
                System.out.printf("    je .L.end.%d\n", count);
                gen(node.then());
                System.out.printf("    jmp .L.begin.%d\n", count);
                System.out.printf(".L.end.%d:\n", count);
                return;
            }
            case For: {
                int count = sequence();
                if (node.init() != null) {
                    gen(node.init());
                }
                System.out.printf(".L.begin.%d:\n", count);
                if (node.cond() != null) {
                    gen(node.cond());
                    System.out.println("    pop rax");
                    System.out.println("    cmp rax, 0");
                    System.out.printf("    je .L.end.%d\n", count);
                }
                gen(node.then());
                if (node.inc() != null) {
                    gen(node.inc());
                }
                System.out.printf("    jmp .L.begin.%d\n", count);
                System.out.printf(".L.end.%d:\n", count);
                return;
            }
        }

        gen(node.lhs());
        gen(node.rhs());

        System.out.println("    pop rdi");
        System.out.println("    pop rax");

        switch (node.kind()) {
            case Add:
                System.out.println("    add rax, rdi");
                break;
            case Sub:
                System.out.println("    sub rax, rdi");
                break;
            case Mul:
                System.out.println("    imul rax, rdi");
                break;
            case Div:
                System.out.println("    cqo");
                System.out.println("    idiv rdi");
                break;
            case Eq:
                System.out.println("    cmp rax, rdi");
                System.out.println("    sete al");
                System.out.println("    movzb rax, al");
                break;
            case Ne:
                System.out.println("    cmp rax, rdi");
                System.out.println("    setne al");
                System.out.println("    movzb rax, al");
                break;
            case Lt:
                System.out.println("    cmp rax, rdi");
                System.out.println("    setl al");
                System.out.println("    movzb rax, al");
                break;
            case Le:
                System.out.println("    cmp rax, rdi");
                System.out.println("    setle al");
                System.out.println("    movzb rax, al");
                break;
        }

        System.out.println("    push rax");
    }
}

